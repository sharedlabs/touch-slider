<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<!--
`touch-slider`


@demo demo/index.html 
-->

<dom-module id="touch-slider">
  <template>
    <style>
      
      :host {
        display: block;
        overflow: hidden;
        position: relative;
        -moz-user-select: -moz-none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
        user-select: none;
      }

      #items {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        bottom: 0;
        left: calc(-100% - 20px);
        overflow: hidden;
        position: absolute;
        top: 0;
        width: calc(300% + 40px);
        will-change: transform;
      }

      .item {
        @apply(--layout-center-center);
        @apply(--layout-flex);
        @apply(--layout);
        position: relative;
        pointer-events: none;
        height: 100%;
      }

      .item:first-child {
        margin-right: 20px;
      }

      .item:last-child {
        margin-left: 20px;
      }

    </style>

    <div id="items"></div>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'touch-slider',

    properties: {

      // current item index
      currentIndex: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_currentIndexChanged'
      },

      // max number of items
      max: {
        type: Number,
        value: Infinity
      },

      // whether the user is dragging an item
      dragging: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },

      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      // The current index in its dom order
      _domCurrentIndex: {
        type: Number,
        observer: '_domCurrentIndexChanged'
      }

    },

    listeners: {
      'touchstart': '_onTouchStart',
      'touchmove': '_onTouchMove',
      'touchend': '_onTouchEnd'
    },

    attached() {
      this._currentIndexChanged(this.currentIndex);
    },

    _onTouchStart(event) {
      this._startX = event.touches[0].clientX;
    },

    _onTouchMove(event) {
      if (typeof this._startX === 'number' && !this.disabled) {
        const dx = event.touches[0].clientX - this._startX;
        this._lastDx = dx;

        if (this.dragging) {
          if (Math.abs(dx) < this._rect.width) {
            this.$.items.style.transform = `translateX(${dx}px`;      
          }
        } else {
          // Don't start dragging until the finger has moved a bit
          if (Math.abs(dx) > 4) {
            this._updateRect();
            this._startDraggingTime = new Date().getTime();
            this._setDragging(true);
          }
        }
      }
    },

    _onTouchEnd(event) {
      if (this.dragging) {
        event.stopPropagation();

          const currentTime = new Date().getTime();
          this._draggingDuration = currentTime - this._startDraggingTime;
          let newIndex = this.currentIndex;

          if (this._draggingDuration / Math.abs(this._lastDx) < 1.2) {
            newIndex = this._lastDx > 0 ? this.currentIndex - 1 : this.currentIndex + 1;
          }

          if (newIndex === this.currentIndex) {
            this._currentIndexChanged(newIndex, newIndex);
          } else {
            this.currentIndex = newIndex;  
          }

        this._startX = null;
        this._lastDx = null;
        this._startDraggingTime = null;
        this._setDragging(false);
      }
   },

    _currentIndexChanged(currentIndex, old) {
      if (!this.isAttached) {
        return;
      }

      // Index should be between 0 and the max value
      this.currentIndex = Math.min(Math.max(0, currentIndex), this.max - 1);
      if (this.currentIndex !== currentIndex) {
        return;
      }

      if (this._animation) this._animation.finish();

      let direction;

      if (currentIndex > old && old !== -1) {
        direction = 'right';
      } else if (currentIndex < old && old !== this.max) {
        direction = 'left';
      } else {
        direction = 'center';
      }

      const dragging = this.dragging;
      let transformFrom, transformTo, duration, easing;

      if (dragging) {
        this._updateRect();
        let translateX = 0;

        if (direction === 'left') {
          translateX = this._rect.width + 20;
        } else if (direction === 'right') {
          translateX = -this._rect.width -20;
        }

        transformFrom = this.$.items.style.transform;
        transformTo = `translate3d(${translateX}px, 0, 0)`;
        console.log(this._draggingDuration)

        duration = this._draggingDuration < 70 ? 150 : 400;
        easing = this._draggingDuration < 70 ? 'cubic-bezier(0.39, 0.575, 0.565, 1)': null;
      } else {
        this._domCurrentIndex = currentIndex;

        let translateX = 0;

        if (direction === 'right') {
          translateX = '20';
        } else if (direction === 'left') {
          translateX = '-20'
        }

        transformFrom =  `translate3d(${translateX}px, 0, 0)`;
        transformTo =  'translate3d(0, 0, 0)';
        duration = 300;
      }

      requestAnimationFrame(_ => {
        this._animation = this.$.items.animate([
          {transform: transformFrom},
          {transform: transformTo}
        ], {
          duration,
          easing: easing || 'cubic-bezier(0.215, 0.61, 0.355, 1)'
        });

        this._animation.onfinish = _ => {
          if (dragging) {
            this._domCurrentIndex = currentIndex;
            this.$.items.style.transform = '';
          }

          this._animation = null;
        };
      });
    },

    _domCurrentIndexChanged(domCurrentIndex) {
      const currentIndexes = [];
      for (let i = domCurrentIndex - 1; i <= domCurrentIndex + 1; i++) {
        currentIndexes.push(i);
      }

      const items = this.$.items.children;
      const unchangedIndexes = [];

      // Remove unnecessary items
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        const itemIndex = Number(item.dataset.index);

        if (currentIndexes.indexOf(itemIndex) < 0) {
          item.remove();
        } else {
          unchangedIndexes.push(itemIndex);
        }
      }

      // Add items
      for (let i = 0; i < 3; i++) {
        const index = currentIndexes[i];

        if (unchangedIndexes.indexOf(index) < 0) {
          this._createItem(currentIndexes[i], i);
        }
      }
    },

    _createItem(index, position) {
      const item = this.create('div');

      item.classList.add('item');
      item.setAttribute('data-index', index);
      this.fire('new-item', {item, index});

      const itemInThatPosition = this.$.items.children[position];

      if (position < 2 && itemInThatPosition) {
        Polymer.dom(this.$.items).insertBefore(item, itemInThatPosition);
      } else {
        Polymer.dom(this.$.items).appendChild(item);
      }
    },

    _updateRect() {
      this._rect = this.getBoundingClientRect();
    }

  });

}());
</script>
