<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<!--
`touch-slider` is a super simple draggable slider for touch devices.

The drag doesn't work with mouse events. IMO for desktop  it's better to have some arrow handles instead.

A slide is a container where you can attach content. There is always three slides attached at the same time, so animations can occur.

When a new slide is rendered the `new-slide` event is fired.  

Use the max attribute to set the max length of items. 

Example:

    <touch-slider on-new-slide="_onNewSlide" max="[[images.length]]"></touch-slider>
    ...
    _onNewSlide(event) {
      const slide = event.detail.slide;
      const slideIndex = event.detail.index;
      const img = document.createElement('img');

      img.setAttribute('src', this.images[slideIndex]);
      Polymer.dom(slide).appendChild(img);
    }

@demo demo/index.html 
-->

<dom-module id="touch-slider">
  <template>
    <style>
      
      :host {
        display: block;
        overflow: hidden;
        position: relative;
        -moz-user-select: -moz-none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
        user-select: none;
      }

      #slides {
        @apply(--layout-horizontal);
        @apply(--layout-wrap);
        bottom: 0;
        left: calc(-100% - 20px);
        overflow: hidden;
        position: absolute;
        top: 0;
        width: calc(300% + 40px);
        will-change: transform;
      }

      .slide {
        @apply(--layout-center-center);
        @apply(--layout-flex);
        @apply(--layout);
        height: 100%;
        pointer-events: none;
        position: relative;
      }

      .slide:first-child {
        margin-right: 20px;
      }

      .slide:last-child {
        margin-left: 20px;
      }

    </style>

    <div id="slides"></div>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'touch-slider',

    properties: {

      /**
       * Current visible slide index.
       */
      currentIndex: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_currentIndexChanged'
      },

      /**
       * Max length of slides.
       */
      max: {
        type: Number,
        value: Infinity
      },

      /**
       * True if the user is dragging a slide. 
       */
      dragging: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },

      /**
       * When true the slider is not draggable.
       */
      dragDisabled: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      /**
       * When a drag ends and a new currentIndex is set, the container is transformed
       * to the new position with a smooth animation. When the animation finishes this value
       * is set to match the currentIndex and it's then when the dom elements are reattached
       * to match the current set of indexes.
       */
      _domCurrentIndex: {
        type: Number,
        observer: '_domCurrentIndexChanged'
      }

    },

    listeners: {
      'touchstart': '_onTouchStart',
      'touchmove': '_onTouchMove',
      'touchend': '_onTouchEnd'
    },

    attached() {
      this._currentIndexChanged(this.currentIndex);
    },

    _onTouchStart(event) {
      this._startX = event.touches[0].clientX;
    },

    _onTouchMove(event) {
      if (typeof this._startX === 'number' && !this.disabled) {
        const dx = event.touches[0].clientX - this._startX;

        if (this.dragging) {
          if (Math.abs(dx) <= this._rect.width) {
            requestAnimationFrame(_ => {
              this.$.slides.style.transform = `translate3d(${dx}px, 0, 0)`;
            });
          }

          this._dx = dx;
        } else {
          // Don't start dragging until the finger has moved a bit
          if (Math.abs(dx) > 4) {
            this._updateRect();
            this._startDraggingTime = new Date().getTime();
            this._setDragging(true);
          }
        }
      }
    },

    _onTouchEnd(event) {
      if (this.dragging) {
        event.stopPropagation();

        const currentTime = new Date().getTime();
        this._draggingDuration = currentTime - this._startDraggingTime;
        let newIndex = this.currentIndex;

        if (this._draggingDuration / Math.abs(this._dx) < 1.2) {
          newIndex = this._dx > 0 ? this.currentIndex - 1 : this.currentIndex + 1;
        }

        if (newIndex === this.currentIndex) {
          this._currentIndexChanged(newIndex, newIndex);
        } else {
          this.currentIndex = newIndex;  
        }

        this._startX = null;
        this._dx = null;
        this._startDraggingTime = null;
        this._setDragging(false);
      }
   },

   /**
    * Animate the current slide to the new currentIndex.
    */
    _currentIndexChanged(currentIndex, old) {
      if (!this.isAttached) {
        return;
      }

      // Index should be between 0 and the max value
      this.currentIndex = Math.min(Math.max(0, currentIndex), this.max - 1);
      if (this.currentIndex !== currentIndex) {
        return;
      }

      // Which direction the slides are moving to.
      let direction;
      if (currentIndex > old && old !== -1) {
        direction = 'right';
      } else if (currentIndex < old && old !== this.max) {
        direction = 'left';
      } else {
        direction = 'center';
      }

      if (this._animation) {
        this._animation.finish();
      }

      if (this.dragging) {
        this._updateRect();

        const isFastDrag = this._draggingDuration < 70;
        let translateX = 0;

        if (direction === 'left') {
          translateX = this._rect.width + 20;
        } else if (direction === 'right') {
          translateX = -this._rect.width -20;
        }

        this._animation = this.$.slides.animate([
          {transform: this.$.slides.style.transform},
          {transform: `translate3d(${translateX}px, 0, 0)`}
        ], {
          duration: isFastDrag < 70 ? 150 : 400,
          easing: isFastDrag < 70 ? 'cubic-bezier(0.39, 0.575, 0.565, 1)': 'cubic-bezier(0.215, 0.61, 0.355, 1)'
        });

        this._animation.onfinish = _ => {
          this._domCurrentIndex = currentIndex;
          this.$.slides.style.transform = '';
          this._animation = null;
        };
      } else {
        // Animation when the currentIndex is changed manually.
        this._domCurrentIndex = currentIndex;
        let translateX = 0;

        if (direction === 'right') {
          translateX = '20';
        } else if (direction === 'left') {
          translateX = '-20'
        }

        this._animation = this.$.slides.animate([
          {transform: `translate3d(${translateX}px, 0, 0)`},
          {transform: 'translate3d(0, 0, 0)'}
        ], {
          easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
          duration: 300
        });

        this._animation.onfinish = _ => {
          this._animation = null;
        };
      }
    },
    
    /**
     * Reattach the slides to match the current index set.
     *
     * @param {!Number} domCurrentIndex
     */
    _domCurrentIndexChanged(domCurrentIndex) {
      const currentIndexes = [];
      for (let i = domCurrentIndex - 1; i <= domCurrentIndex + 1; i++) {
        currentIndexes.push(i);
      }

      const slides = this.$.slides.children;
      const unchangedIndexes = [];

      // Remove unnecessary slides
      for (let i = slides.length - 1; i >= 0; i--) {
        const slide = slides[i];
        const slideIndex = Number(slide.dataset.index);

        if (currentIndexes.indexOf(slideIndex) < 0) {
          slide.remove();
        } else {
          unchangedIndexes.push(slideIndex);
        }
      }

      // Add slides
      for (let i = 0; i < 3; i++) {
        const index = currentIndexes[i];

        if (unchangedIndexes.indexOf(index) < 0) {
          this._renderSlide(currentIndexes[i], i);
        }
      }
    },

    /**
     * @param {!Number} index - The index of the slide.
     * @param {!Number} slideIndex - Represents the slide child index. It can be 0, 1 or 2. 
     */
    _renderSlide(index, slideIndex) {
      const slide = this.create('div');

      slide.classList.add('slide');
      slide.setAttribute('data-index', index);
      this.fire('new-slide', {slide, index});

      const slideInThatPosition = this.$.slides.children[slideIndex];

      if (slideIndex < 2 && slideInThatPosition) {
        Polymer.dom(this.$.slides).insertBefore(slide, slideInThatPosition);
      } else {
        Polymer.dom(this.$.slides).appendChild(slide);
      }
    },

    _updateRect() {
      this._rect = this.getBoundingClientRect();
    }

  });

}());
</script>
