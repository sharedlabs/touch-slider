<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<!--
`touch-slider`


@demo demo/index.html 
-->

<dom-module id="touch-slider">
  <template>
    <style>
      
      :host {
        display: block;
        overflow: hidden;
        position: relative;
        -moz-user-select: -moz-none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
        user-select: none;
      }

      #items {
        @apply(--layout-horizontal);
        @apply(--layout-center-center);
        bottom: 0;
        left: -100%;
        overflow: hidden;
        position: absolute;
        top: 0;
        width: 300%;
        will-change: transform;
      }

      .item {
        @apply(--layout-flex);
        height: 100%;
        pointer-events: none;
      }

    </style>

    <div id="items"></div>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'touch-slider',

    properties: {

      // current item index
      currentIndex: {
        type: Number,
        value: 0,
        notify: true,
        observer: '_currentIndexChanged'
      },

      // max number of items
      max: {
        type: Number,
        value: Infinity
      },

      // whether the user is dragging an item
      dragging: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },

      disabled: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },

      // The current index in its dom order
      _domCurrentIndex: {
        type: Number,
        observer: '_domCurrentIndexChanged'
      }

    },

    listeners: {
      'pointerdown': '_onPointerDown',
      'touchmove': '_onTouchMove',
      'touchend': '_onTouchEnd'
    },

    attached() {
      this._currentIndexChanged(this.currentIndex);
    },

    _onPointerDown(event) {
      if (event.pointerType === 'touch') {
        this._startX = event.clientX;
      }
    },

    _onTouchMove(event) {
      if (typeof this._startX === 'number' && !this.disabled) {
        const dx = event.touches[0].clientX - this._startX;
        this._lastDx = dx;

        if (this.dragging) {
          if (Math.abs(dx) < this._rect.width) {
            this.$.items.style.transform = `translateX(${dx}px`;      
          }
        } else {
          // Don't start dragging until the finger has moved a bit
          if (Math.abs(dx) > 8) {
            this._updateRect();
            this._startDraggingTime = new Date().getTime();
            this._setDragging(true);
          }
        }
      }
    },

    _onTouchEnd(event) {
      if (this.dragging) {
        event.stopPropagation();

        // Set a new index if 
        const dx = this._lastDx;
        const currentTime = new Date().getTime();
        const timePassed = currentTime - this._startDraggingTime;
        const steps = Math.abs(dx);
        const minSteps = this._rect.width / 8;
        const maxSteps = this._rect.width / 3;

        let newIndex = this.currentIndex;

        if ((Math.abs(timePassed / dx) <= 1 && steps >= minSteps) || steps >= maxSteps) {
          newIndex = dx > 0 ? newIndex - 1 : newIndex + 1;
        }

        console.log(newIndex);
        
        if (newIndex === this.currentIndex) {
          this._currentIndexChanged(newIndex, newIndex);
        } else {
          this.currentIndex = newIndex;  
        }

        this._lastDx = null;
        this._setDragging(false);
      }
  
      this._startX = null;
    },

    /**
     * When the currentIndex changes, we have to move the slider to that item.
     */
    _currentIndexChanged(currentIndex, old) {
      if (typeof this.max === 'number' && currentIndex + 1 > this.max) {
        this.currentIndex = currentIndex - 1;
        return;
      }

      if (currentIndex < 0) {
        this.currentIndex = 0;
        return;
      }

      let translateX = null;

      this._updateRect();

      if (currentIndex === old-1 && old !== this.max) {
        translateX = this._rect.width;
      } else if (currentIndex === old + 1 && old !== -1) {
        translateX = -this._rect.width;
      } else if (currentIndex === old || old === this.max || old === -1) {
        translateX = 0;
      }

      if (translateX === null) {
        this._visibleCurrentIndex = currentIndex;
        return;
      }

      requestAnimationFrame(_ => {
        const animation = this.$.items.animate([
          {transform: this.$.items.style.transform || 'translate3d(0, 0 ,0)'},
          {transform: `translate3d(${translateX}px, 0, 0)`}
        ], {
          duration: 500,
          easing: 'cubic-bezier(0.075, 0.82, 0.165, 1)'          
        });

        animation.onfinish = _ => {
          this._domCurrentIndex = currentIndex;
          this.$.items.style.transform = '';
        };
      });
    },

    _domCurrentIndexChanged(domCurrentIndex) {
      const currentIndexes = [];
      for (let i = domCurrentIndex - 1; i <= domCurrentIndex + 1; i++) {
        currentIndexes.push(i);
      }

      const items = Array.from(this.$.items.children);
      const itemsLength = items.length;
      const unchangedIndexes = [];

      // Remove unnecessary items
      for (let i = 0; i < itemsLength; i++) {
        const item = items[i];
        const itemIndex = Number(item.dataset.index);
        if (currentIndexes.indexOf(itemIndex) < 0) {
          item.remove();
        } else {
          unchangedIndexes.push(itemIndex);
        }
      }

      // Add items
      for (let i = 0; i < 3; i++) {
        const index = currentIndexes[i];

        if (unchangedIndexes.indexOf(index) < 0) {
          this._createItem(currentIndexes[i], i);
        }
      }
    },

    _createItem(index, position) {
      const item = this.create('div');

      item.classList.add('item');
      item.setAttribute('index', index);
      this.fire('new-item', {item, index});

      const itemInThatPosition = this.$.items.children[position];

      if (position < 2 && itemInThatPosition) {
        Polymer.dom(this.$.items).insertBefore(item, itemInThatPosition);
      } else {
        Polymer.dom(this.$.items).appendChild(item);
      }
    },

    _updateRect() {
      this._rect = this.getBoundingClientRect();
    }

  });

}());
</script>
