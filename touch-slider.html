<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<!--
`touch-slider`


@demo demo/index.html 
-->

<dom-module id="touch-slider">
  <template>
    <style>
      
      :host {
        display: block;
        overflow: hidden;
        position: relative;
        -moz-user-select: -moz-none;
        -khtml-user-select: none;
        -webkit-user-select: none;
        -o-user-select: none;
        user-select: none;
      }

      #items {
        @apply(--layout-horizontal);
        @apply(--layout-center-center);
        width: 300%;
        overflow: hidden;

        position: absolute;
        left: -100%;
        top: 0;
        bottom: 0;
      }

      .item {
        @apply(--layout-flex);
        height: 100%;
        pointer-events: none;
        will-change: transform;
      }

    </style>

    <div id="items" on-track="_onTrack"></div>

  </template>
</dom-module>

<script>
(function() {
  'use strict';

  Polymer({

    is: 'touch-slider',

    properties: {

      currentIndex: {
        type: Number,
        value: 0,
        observer: '_currentIndexChanged'
      },

      _visibleCurrentIndex: {
        type: Number,
        observer: '_visibleCurrentIndexChanged'
      },

      max: Number

    },

    attached() {
      this._currentIndexChanged(this.currentIndex);
    },

    goToNext() {
      this.currentIndex += 1;
    },

    goToPrevious() {
      this.currentIndex -= 1;
    },

    _currentIndexChanged(currentIndex, old) {
      if (!this.isAttached) {
        return;
      }

      if (typeof this.max === 'number' && currentIndex + 1 > this.max) {
        this.currentIndex = currentIndex - 1;
        return;
      }

      if (currentIndex < 0) {
        this.currentIndex = 0;
        return;
      }

      if (this._animation) {
        this._animation.finish();
      }

      this._rect = this.getBoundingClientRect();

      let translateX = null;

      if (currentIndex === old-1 && old !== this.max) {
        translateX = this._rect.width;
      } else if (currentIndex === old + 1 && old !== -1) {
        translateX = -this._rect.width;
      } else if (currentIndex === old || old === this.max || old === -1) {
        translateX = 0;
      }

      if (translateX === null) {
        this._visibleCurrentIndex = currentIndex;
      } else {
        requestAnimationFrame(() => {
          this._animation = this.$.items.animate([
            {transform: this.$.items.style.transform || 'translateX(0px)'},
            {transform: `translateX(${translateX}px)`}
          ], {
            duration: 500,
            easing: 'cubic-bezier(0.075, 0.82, 0.165, 1)'
          });

          this._animation.onfinish = () => {
            this._visibleCurrentIndex = currentIndex;
            this.$.items.style.transform = '';
            this._animation = null;
          };
        });
      }
    },

    _visibleCurrentIndexChanged(visibleCurrentIndex) {
      const currentIndexes = [];
      for (let i = visibleCurrentIndex - 1; i <= visibleCurrentIndex + 1; i++) {
        currentIndexes.push(i);
      }

      const items = Array.from(this.$.items.children);
      const itemsLength = items.length;
      const unchangedIndexes = [];

      // Remove unnecessary items
      for (let i = 0; i < itemsLength; i++) {
        const item = items[i];
        const itemIndex = Number(item.dataset.index);
        if (currentIndexes.indexOf(itemIndex) < 0) {
          item.remove();
        } else {
          unchangedIndexes.push(itemIndex);
        }
      }

      // Add items
      for (let i = 0; i < 3; i++) {
        const index = currentIndexes[i];

        if (unchangedIndexes.indexOf(index) < 0) {
          this._createItem(currentIndexes[i], i);
        }
      }
    },

    _createItem(index, position) {
      const item = this.create('div');

      item.classList.add('item');
      item.setAttribute('data-index', index);
      this.fire('new-item', {item, index});

      const itemInThatPosition = this.$.items.children[position];

      if (position < 2 && itemInThatPosition) {
        Polymer.dom(this.$.items).insertBefore(item, itemInThatPosition);
      } else {
        Polymer.dom(this.$.items).appendChild(item);
      }
    },

    _onTrack(event) {
      switch (event.detail.state) {
        case 'start': this._trackStart(event); break;
        case 'track': this._track(event); break;
        case 'end': this._trackEnd(event); break;
      }      
    },

    _trackStart(event) {
      event.preventDefault();

      if (this._animation) {
        this._animation.finish();
      }

      this._rect = this.getBoundingClientRect();
      this._startTime = new Date().getTime();
    },

    _track(event) {
      let dx = event.detail.dx;

      if (Math.abs(dx) < this._rect.width) {
        this.$.items.style.transform = `translateX(${dx}px)`;
      }
    },

    _trackEnd(event) {
      const currentTime = new Date().getTime();
      const timePassed = currentTime - this._startTime;
      const dx = event.detail.dx;
      const steps = Math.abs(dx);
      const minSteps = this._rect.width / 8;
      const maxSteps = this._rect.width / 3;

      let newIndex = this.currentIndex;

      if ((Math.abs(timePassed / dx) <= 1 && steps >= minSteps) || steps >= maxSteps) {
       newIndex = dx > 0 ? newIndex - 1 : newIndex + 1;
      }

      if (newIndex === this.currentIndex) {
        this._currentIndexChanged(newIndex, newIndex);
      } else {
        this.currentIndex = newIndex;  
      }
    }

  });

}());
</script>
